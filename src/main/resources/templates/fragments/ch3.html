<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">

<th:block>
    <h2>Chapter3. Advisor API</h2><br>
    <h4>1. Core Components</h4><br>
    <p>Spring AI Advisors API는 Spring 애플리케이션에서 AI 기반 상호작용을 가로채고, 수정하고, 개선할 수 있는 유연하고 강력한 방법을 제공합니다. Advisors API를 활용하여 개발자는 더욱 정교하고 재사용 가능하며 유지 관리가 용이한 AI 구성 요소를 만들 수 있습니다.</p>

    <p>주요 이점으로는 반복적인 생성 AI 패턴을 캡슐화하고, 대규모 언어 모델(LLM)과 주고받는 데이터를 변환하고, 다양한 모델과 사용 사례에 걸쳐 이식성을 제공하는 것이 있습니다.</p>
    <p>
    <pre>
        ChatMemory chatMemory = ... // Initialize your chat memory store
        VectorStore vectorStore = ... // Initialize your vector store

        var chatClient = ChatClient.builder(chatModel)
            .defaultAdvisors(
                MessageChatMemoryAdvisor.builder(chatMemory).build(), // chat-memory advisor
                QuestionAnswerAdvisor.builder(vectorStore).build()    // RAG advisor
            )
            .build();

        var conversationId = "678";

        String response = this.chatClient.prompt()
            // Set advisor parameters at runtime
            .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))
            .user(userText)
            .call()
            .content();
    </pre>
    </p>
    <p>API는 비스트리밍 시나리오 의 경우 CallAdvisor및 와 스트리밍 시나리오의 경우 및 로 구성됩니다. 또한 , 채팅 완료 응답을 위한 봉인되지 않은 프롬프트 요청을 나타내는 기능 도 포함됩니다. 두 API 모두 어드바이저 체인 전체에서 상태를 공유합니다.</p>
    <img th:src="@{/imgs/advisor1.png}" width="600px;"><br><a href="https://docs.spring.io/spring-ai/reference/api/advisors.html">출처:docs.springai.io</a><br><br>



    <p>Spring AI 프레임워크에서 생성된 어드바이저 체인은 getOrder()값 순서대로 여러 어드바이저를 순차적으로 호출할 수 있도록 합니다. 값이 낮은 어드바이저가 먼저 실행됩니다. 자동으로 추가된 마지막 어드바이저가 LLM에 요청을 전송합니다.</p>

    <img th:src="@{/imgs/advisor2.png}" width="600px;"><br><a href="https://docs.spring.io/spring-ai/reference/api/advisors.html">출처:docs.springai.io</a><br><br>

    <ol>
        <li>Spring AI 프레임워크는 ChatClientRequest사용자의 Prompt빈 advisor 객체와 함께 객체를 생성합니다 context.</li>
        <li>체인의 각 어드바이저는 요청을 처리하고 잠재적으로 수정할 수 있습니다. 또는 다음 엔티티를 호출하지 않음으로써 요청을 차단할 수 있습니다. 후자의 경우, 어드바이저는 응답을 작성해야 합니다.</li>
        <li>프레임워크가 제공하는 최종 고문은 요청을 .로 보냅니다 Chat Model.</li>
        <li>그런 다음 채팅 모델의 응답은 어드바이저 체인을 통해 다시 전달되어 ChatClientResponse. 나중에 공유 어드바이저 context인스턴스를 포함합니다.</li>
        <li>각 자문자는 응답을 처리하거나 수정할 수 있습니다.</li>
        <li>최종본은 . ChatClientResponse을 추출하여 클라이언트에게 반환됩니다 ChatCompletion.</li>
        <li><span><a href="https://docs.spring.io/spring-ai/reference/api/advisors.html">SpringAi 참고</a></span></li>
    </ol><br>


    <h4>2. Advisor Order</h4><br>
    <p>체인 내 어드바이저의 실행 순서는 getOrder()메서드에 따라 결정됩니다. 이해해야 할 핵심 사항은 다음과 같습니다.</p>
    <ul>
        <li>낮은 주문 값을 가진 자문가가 먼저 실행됩니다.</li>
        <li>어드바이저 체인은 스택으로 작동합니다.</li>
        <ul>
            <li>체인의 첫 번째 고문이 요청을 가장 먼저 처리합니다.</li>
            <li>또한 응답을 처리하는 마지막 프로세스입니다.</li>
        </ul>
        <li>실행 순서를 제어하려면:</li>
        <ul>
            <li>Ordered.HIGHEST_PRECEDENCE 체인에서 먼저 실행되도록(요청 처리 시 먼저, 응답 처리 시 마지막으로) 주문을 닫습니다.</li>
            <li>Ordered.LOWEST_PRECEDENCE 체인에서 마지막 으로 실행되도록 주문을 닫습니다 (요청 처리의 경우 마지막, 응답 처리의 경우 첫 번째).</li>
        </ul>
        <li>값이 높을수록 우선순위가 낮은 것으로 해석됩니다.</li>
        <li>여러 자문자가 동일한 주문 가치를 갖는 경우, 실행 주문은 보장되지 않습니다.</li>
        <li><span><a href="https://docs.spring.io/spring-ai/reference/api/advisors.html">SpringAi 참고</a></span></li>
    </ul><br>


    <h4>Streaming vs Non-Streaming</h4>
    <img th:src="@{/imgs/advisor3.png}" width="600px;"><br><a href="https://docs.spring.io/spring-ai/reference/api/advisors.html">출처:docs.springai.io</a><br><br>
    <ul>
        <li>스트리밍이 아닌 자문자는 완전한 요청과 응답을 처리합니다.</li>
        <li>스트리밍 어드바이저는 반응형 프로그래밍 개념(예: 응답의 경우 Flux)을 사용하여 요청과 응답을 연속 스트림으로 처리합니다.</li>
    </ul><br>

</th:block>

</html>