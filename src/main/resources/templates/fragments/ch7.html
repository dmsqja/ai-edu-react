<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">

<th:block>
    <h2>Chapter7. Embedding Model</h2><br>
    <h4>1. Embedding Model</h4><br>
    <p>임베딩은 입력 간의 관계를 포착하는 텍스트, 이미지 또는 비디오의 숫자적 표현입니다.</p>
    <a href="https://docs.spring.io/spring-ai/reference/api/vectordbs/understand-vectordbs.html">벡터 이해, 출처:docs.springai.io</a><br>
    <img th:src="@{/imgs/embedding.png}" width="600px;"><br><a href="https://qdrant.tech/articles/what-are-embeddings/">출처:qdrant.tech</a><br><br>
    <p>임베딩은 텍스트, 이미지, 비디오를 벡터라고 하는 부동 소수점 숫자 배열로 변환하는 방식으로 작동합니다. 이 벡터는 텍스트, 이미지, 비디오의 의미를 포착하도록 설계되었습니다. 임베딩 배열의 길이를 벡터의 차원이라고 합니다.</p>
    <p>두 텍스트의 벡터 표현 간의 수치적 거리를 계산함으로써, 애플리케이션은 임베딩 벡터를 생성하는 데 사용된 객체 간의 유사성을 판단할 수 있습니다.</p>
    <p>Spring AI에서는  EmbeddingModel인터페이스를 제공 해서 AI 및 머신러닝의 임베딩 모델과 간편하게 통합되도록 설계되었습니다. 주요 기능은 텍스트를 수치 벡터, 즉 임베딩으로 변환하는 것입니다. 이러한 임베딩은 의미 분석 및 텍스트 분류와 같은 다양한 작업에 필수적입니다.</p>
    <p>EmbeddingModel 인터페이스의 디자인은 두 가지 주요 목표를 중심으로 이루어집니다.</p>
    <ul>
        <li>Portability: 이 인터페이스는 다양한 임베딩 모델에 쉽게 적용할 수 있도록 보장합니다. 개발자는 최소한의 코드 변경으로 다양한 임베딩 기법이나 모델 간에 전환할 수 있습니다. 이러한 설계는 Spring의 모듈성 및 상호 교환성 철학과 일치합니다.</li>
        <li>Simplicity: EmbeddingModel은 텍스트를 임베딩으로 변환하는 과정을 간소화합니다. embed(String text)및 와 같은 직관적인 메서드를 제공함으로써 embed(Document document)원시 텍스트 데이터와 임베딩 알고리즘을 처리하는 복잡성을 제거합니다. 이러한 디자인 선택은 개발자, 특히 AI 초보자가 기본 메커니즘을 깊이 파고들지 않고도 애플리케이션에서 임베딩을 더 쉽게 활용할 수 있도록 합니다.</li>
    </ul>
    <p>Spring AI는 API를 사용하여 사용자 정의 RAG 흐름을 직접 구축하거나 기본 RAG 흐름을 사용할 수 있는 모듈식 아키텍처를 제공하여 RAG를 지원합니다</p><br>
    <h4>2. Vector Databases</h4><br>
    <a href="https://docs.spring.io/spring-ai/reference/api/vectordbs.html">출처:docs.springai.io</a><br>
    <p>벡터 데이터베이스는 인공지능 애플리케이션에서 필수적인 역할을 하는 특수한 유형의 데이터베이스입니다.</p>
    <p>벡터 데이터베이스에서 쿼리는 기존 관계형 데이터베이스와 다릅니다. 정확히 일치하는 항목을 찾는 대신 유사도 검색을 수행합니다. 벡터를 쿼리로 입력하면 벡터 데이터베이스는 해당 쿼리 벡터와 "유사한" 벡터들을 반환합니다. 이러한 유사도 계산 방식에 대한 자세한 내용은 벡터 유사도(Vector Similarity) 에서 확인할 수 있습니다 .</p>
    <p>벡터 데이터베이스는 데이터를 AI 모델과 통합하는 데 사용됩니다. 사용의 첫 단계는 데이터를 벡터 데이터베이스에 로드하는 것입니다. 그런 다음 사용자 쿼리가 AI 모델에 전송되면 먼저 유사한 문서 집합을 검색합니다. 이러한 문서는 사용자 질문의 맥락 역할을 하며 사용자 쿼리와 함께 AI 모델로 전송됩니다. 이 기술을 검색 증강 생성(RAG, Retrieval Augmented Generation) 이라고 합니다 .</p>
    <p>벡터 데이터베이스에 데이터를 삽입하려면 데이터를 Document객체로 캡슐화해야 합니다. 이 Document클래스는 PDF나 Word 문서와 같은 데이터 소스의 콘텐츠를 캡슐화하고 문자열로 표현된 텍스트를 포함합니다. 또한 파일 이름과 같은 세부 정보를 포함한 키-값 쌍 형태의 메타데이터도 포함합니다.
    <p>벡터 데이터베이스에 텍스트 내용을 삽입하면, float[]임베딩 모델을 사용하여 텍스트 내용이 숫자형 배열, 즉 벡터 임베딩으로 변환됩니다. Word2Vec , GLoVE , BERT 또는 OpenAI의 임베딩 모델과 같은 임베딩 모델을 사용하여 text-embedding-ada-002단어, 문장 또는 단락을 이러한 벡터 임베딩으로 변환합니다.</p>
    <p>벡터 데이터베이스의 역할은 이러한 임베딩에 대한 유사성 검색을 저장하고 지원하는 것입니다. 임베딩 자체를 생성하지는 않습니다. 벡터 임베딩을 생성하려면 를 EmbeddingModel활용해야 합니다.</p>
    <p>벡터 데이터베이스의 임베딩을 계산하려면 사용 중인 상위 수준 AI 모델과 일치하는 임베딩 모델을 선택해야 합니다.
        OpenAiEmbeddingModel예를 들어, OpenAI의 ChatGPT에서는 와 라는 모델을 사용합니다 text-embedding-ada-002.</p>
    <p>인터페이스의 메서드 similaritySearch를 사용하면 주어진 쿼리 문자열과 유사한 문서를 검색할 수 있습니다. 이러한 메서드는 다음 매개변수를 사용하여 미세 조정할 수 있습니다.</p>
    <ul>
        <li>k: 반환할 유사 문서의 최대 개수를 지정하는 정수입니다. 이는 종종 '상위 K' 검색 또는 'K 최근접 이웃'(KNN)이라고 합니다.</li>
        <li>threshold: 0에서 1까지의 double 값으로, 1에 가까울수록 유사도가 높음을 나타냅니다. 기본적으로 임계값을 0.75로 설정하면 유사도가 이 값보다 높은 문서만 반환됩니다.</li>
        <li>Filter.Expression: SQL의 'where' 절과 유사하게 기능하는 유창한 DSL(도메인 특정 언어) 표현식을 전달하는 데 사용되는 클래스이지만, .의 메타데이터 키-값 쌍에만 적용됩니다 Document.</li>
        <pre style="border:1px solid cornflowerblue">

        return vectorStore.similaritySearch(
            SearchRequest.builder()
                  .query(question)
                  .topK(1)
                  .similarityThreshold(0.5)
                  .filterExpression(b.and(b.eq("director", director), b.gte("year", year)).build()).build());
        </pre>
        <li>filterExpression: 필터 표현식을 문자열로 받는 ANTLR4 기반 외부 DSL입니다. 예를 들어, country, year, 와 같은 메타데이터 키를 사용하는 경우 isActive다음과 같은 표현식을 사용할 수 있습니다.country == 'UK' && year >= 2020 && isActive == true.</li>
        <pre style="border:1px solid cornflowerblue">

        return vectorStore.similaritySearch(
            SearchRequest.builder()
                    .query(question)
                    .topK(1)
                    .similarityThreshold(0.5)
                    .filterExpression("section == '%s' and name == '%s'".formatted(section,name)).build());
        </pre>
    </ul><br>
    <h4>3. PGvector</h4><br>
    <a href="https://docs.spring.io/spring-ai/reference/api/vectordbs/pgvector.html">출처:docs.springai.io</a><br>
    <p>PGvector 는 PostgreSQL용 오픈소스 확장 프로그램으로, 머신 러닝으로 생성된 임베딩을 저장하고 검색할 수 있도록 지원합니다. 사용자가 정확한 이웃과 대략적인 최근접 이웃을 모두 식별할 수 있도록 다양한 기능을 제공합니다. 인덱싱 및 쿼리를 포함한 다른 PostgreSQL 기능과 원활하게 작동하도록 설계되었습니다.</p>
    <p>Spring AI에사 PGvector를 사용하면 Springboot가 시작 되면서 기본적으로 PostgreSQL에 vector_store라는 테이블이 생성 되면서 동작 합니다. </p>
    <p>필요 하면 사용자가 테이블을 생성 하여 사용이 가능 합니다.</p>
    <p>만약 chat memory를 PGvector에 저장 한다면 이때도 자동적으로 spring_ai_chat_memory라는 테이블이 생성이 됩니다.</p>
    <p>다음은 PGVector를 사용하기위한 Spring Boot에서의 환경 설정 입니다.(yml)</p>
    <pre style="border:1px solid cornflowerblue">

        spring:
          datasource:
            url: jdbc:postgresql://localhost:5432/postgres
            username: user01
            password: 111111
            driver-class-name: org.postgresql.Driver
          ai:
            chat:
              memory:
                repository:
                  jdbc:
                    # resources/schema/chat_pgvector.sql
                    schema: classpath:schema/chat_pgvector.sql
                    initialize-schema: always
            vectorstore:
              pgvector:
                initialize-schema: true
    </pre><br>
    <p>resources/schema/chat_pgvector.sql</p>
    <pre style="border:1px solid cornflowerblue">

        DROP TABLE IF EXISTS chat_pgvector CASCADE;
        CREATE TABLE IF NOT EXISTS public.chat_pgvector (
            id VARCHAR(255) PRIMARY KEY,
            content TEXT,
            metadata JSONB,
            embedding VECTOR(1536)
        );
    </pre>


</th:block>

</html>